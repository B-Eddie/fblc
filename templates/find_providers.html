{% extends "base.html" %} {% block content %}
<div class="p-10">
  <h1 class="mb-8 text-3xl font-bold text-orange-600">
    Find Healthcare Providers
  </h1>

  <div class="mb-8">
    <div class="flex flex-wrap gap-4 mb-4">
      <button
        id="filterAll"
        class="px-4 py-2 font-bold text-black transition duration-300 bg-orange-500 rounded-full hover:bg-orange-600"
      >
        All
      </button>
      {% for specialty in top_specialties %}
      <button
        id="filter{{ specialty|replace(' ', '-') }}"
        class="px-4 py-2 font-bold text-orange-800 transition duration-300 bg-orange-100 rounded-full hover:bg-orange-200"
      >
        {{ specialty }}
      </button>
      {% endfor %}
    </div>
    <div class="flex items-center gap-4">
      <label for="sortDistance" class="font-medium text-orange-800"
        >Sort by distance:</label
      >
      <select
        id="sortDistance"
        class="p-2 text-orange-800 border border-orange-300 rounded-md bg-orange-50"
      >
        <option value="asc">Nearest first</option>
        <option value="desc">Farthest first</option>
      </select>
    </div>
  </div>

  <div id="providerList" class="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
    <!-- Provider cards will be dynamically inserted here -->
  </div>
  <!-- Modal for booking appointments -->
  <div
    id="bookingModal"
    class="fixed inset-0 items-center justify-center hidden bg-gray-600 bg-opacity-50"
  >
    <div class="w-full max-w-5xl p-8 bg-orange-200 rounded-lg shadow-xl">
      <h2 id="modalTitle" class="mb-4 text-2xl font-bold text-orange-600"></h2>
      <div
        id="modalMap"
        class="w-full h-48 mb-6 rounded-lg"
        style="min-height: 200px"
      ></div>

      <!-- Two-column layout -->
      <div class="grid grid-cols-1 gap-6 md:grid-cols-2">
        <!-- Left column: Calendar -->
        <div class="p-4 bg-white rounded-lg shadow">
          <h3 class="mb-3 text-lg font-semibold text-gray-800">
            Available Times
          </h3>
          <div id="appointmentCalendar" class="mb-3">
            <div class="flex items-center justify-between mb-2">
              <button
                id="prevDate"
                class="p-1 text-orange-600 rounded hover:text-orange-700 hover:bg-orange-100"
              >
                <svg
                  class="w-5 h-5"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                >
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M15 19l-7-7 7-7"
                  ></path>
                </svg>
              </button>
              <span
                id="currentDate"
                class="px-2 py-1 font-medium rounded bg-orange-50"
              ></span>
              <button
                id="nextDate"
                class="p-1 text-orange-600 rounded hover:text-orange-700 hover:bg-orange-100"
              >
                <svg
                  class="w-5 h-5"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                >
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M9 5l7 7-7 7"
                  ></path>
                </svg>
              </button>
            </div>
            <div
              id="timeSlots"
              class="border border-gray-200 rounded p-2 bg-gray-50 min-h-[150px] max-h-[250px] overflow-y-auto"
            >
              <!-- Time slots will be added here dynamically -->
            </div>
          </div>
          <div class="flex flex-wrap items-center gap-3 text-xs">
            <div class="flex items-center">
              <span
                class="inline-block w-3 h-3 mr-1 bg-green-500 rounded-sm"
              ></span>
              <span>Your confirmed appointment</span>
            </div>
            <div class="flex items-center">
              <span
                class="inline-block w-3 h-3 mr-1 bg-green-100 border border-green-300 rounded-sm"
              ></span>
              <span>Available confirmed slot</span>
            </div>
          </div>
        </div>

        <!-- Right column: Combined provider details and booking form -->
        <div class="p-4 bg-white rounded-lg shadow">
          <!-- Provider details at the top -->
          <div class="pb-4 mb-6 border-b border-gray-200">
            <h3 class="mb-3 text-lg font-semibold text-gray-800">
              Provider Information
            </h3>
            <div class="space-y-2 text-gray-600">
              <p id="modalSpecialty"></p>
              <p id="modalAddress"></p>
              <p id="modalPhone"></p>
            </div>
          </div>

          <!-- Booking form below in the same card -->
          <div>
            <h3 class="mb-3 text-lg font-semibold text-gray-800">
              Book Your Appointment
            </h3>
            <form id="bookingForm" class="space-y-4">
              <div>
                <label
                  for="appointmentDate"
                  class="block text-sm font-medium text-gray-700"
                  >Date</label
                >
                <input
                  type="date"
                  id="appointmentDate"
                  name="appointmentDate"
                  required
                  class="block w-full p-2 mt-1 border border-orange-300 rounded-md shadow-sm"
                />
              </div>
              <div>
                <label
                  for="appointmentTime"
                  class="block text-sm font-medium text-gray-700"
                  >Time</label
                >
                <input
                  type="time"
                  id="appointmentTime"
                  name="appointmentTime"
                  required
                  class="block w-full p-2 mt-1 border border-orange-300 rounded-md shadow-sm"
                />
              </div>
              <div>
                <label
                  for="appointmentType"
                  class="block text-sm font-medium text-gray-700"
                  >Appointment Type</label
                >
                <input
                  type="text"
                  id="appointmentType"
                  name="appointmentType"
                  required
                  class="block w-full p-2 mt-1 border border-orange-300 rounded-md shadow-sm"
                />
              </div>
              <div class="flex justify-end pt-2 space-x-4">
                <button
                  type="button"
                  id="closeModal"
                  class="px-4 py-2 font-bold text-gray-800 transition duration-300 bg-gray-300 rounded-full hover:bg-gray-400"
                >
                  Cancel
                </button>
                <button
                  type="submit"
                  class="px-4 py-2 font-bold text-black transition duration-300 bg-orange-500 rounded-full hover:bg-orange-600"
                >
                  Book Appointment
                </button>
              </div>
            </form>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Add this modal at the end of your body, just before the closing div -->
  <div
    id="reviewsModal"
    class="fixed inset-0 items-center justify-center hidden bg-gray-600 bg-opacity-50"
  >
    <div class="w-full max-w-lg p-6 bg-white rounded-lg shadow-xl">
      <div class="flex items-center justify-between mb-4">
        <h2
          id="reviewsModalTitle"
          class="text-xl font-bold text-orange-600"
        ></h2>
        <div class="flex items-center">
          <span class="mr-2">Sort by:</span>
          <select
            id="reviewSort"
            class="p-1 text-sm border border-orange-300 rounded-md bg-orange-50"
          >
            <option value="recent">Most Recent</option>
            <option value="highest">Highest Rating</option>
            <option value="lowest">Lowest Rating</option>
          </select>
        </div>
      </div>

      <div class="mb-4">
        <div class="flex items-center mb-2">
          <div class="flex items-center mr-3">
            <span id="modalRating" class="text-xl font-bold text-orange-600"
              >--</span
            >
            <div
              id="modalStarsContainer"
              class="flex ml-1 text-orange-400"
            ></div>
          </div>
          <span id="modalReviewCount" class="text-sm text-gray-600"
            >0 reviews</span
          >
        </div>
      </div>

      <div id="reviewsList" class="mb-6 overflow-y-auto max-h-96">
        <!-- Reviews will be dynamically inserted here -->
        <div class="flex items-center justify-center p-8 text-gray-500">
          <span>Loading reviews...</span>
        </div>
      </div>

      <form id="reviewForm" class="pt-4 border-t border-gray-200">
        <h3 class="mb-3 text-lg font-medium text-gray-800">Add Your Review</h3>
        <div class="flex items-center mb-4">
          <span class="mr-3">Your Rating:</span>
          <div class="flex text-gray-300" id="ratingSelector">
            <svg
              class="w-6 h-6 cursor-pointer rating-star hover:text-orange-400"
              data-rating="1"
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 24 24"
              fill="currentColor"
            >
              <path
                fill-rule="evenodd"
                d="M10.788 3.21c.448-1.077 1.976-1.077 2.424 0l2.082 5.007 5.404.433c1.164.093 1.636 1.545.749 2.305l-4.117 3.527 1.257 5.273c.271 1.136-.964 2.033-1.96 1.425L12 18.354 7.373 21.18c-.996.608-2.231-.29-1.96-1.425l1.257-5.273-4.117-3.527c-.887-.76-.415-2.212.749-2.305l5.404-.433 2.082-5.006z"
                clip-rule="evenodd"
              />
            </svg>
            <svg
              class="w-6 h-6 cursor-pointer rating-star hover:text-orange-400"
              data-rating="2"
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 24 24"
              fill="currentColor"
            >
              <path
                fill-rule="evenodd"
                d="M10.788 3.21c.448-1.077 1.976-1.077 2.424 0l2.082 5.007 5.404.433c1.164.093 1.636 1.545.749 2.305l-4.117 3.527 1.257 5.273c.271 1.136-.964 2.033-1.96 1.425L12 18.354 7.373 21.18c-.996.608-2.231-.29-1.96-1.425l1.257-5.273-4.117-3.527c-.887-.76-.415-2.212.749-2.305l5.404-.433 2.082-5.006z"
                clip-rule="evenodd"
              />
            </svg>
            <svg
              class="w-6 h-6 cursor-pointer rating-star hover:text-orange-400"
              data-rating="3"
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 24 24"
              fill="currentColor"
            >
              <path
                fill-rule="evenodd"
                d="M10.788 3.21c.448-1.077 1.976-1.077 2.424 0l2.082 5.007 5.404.433c1.164.093 1.636 1.545.749 2.305l-4.117 3.527 1.257 5.273c.271 1.136-.964 2.033-1.96 1.425L12 18.354 7.373 21.18c-.996.608-2.231-.29-1.96-1.425l1.257-5.273-4.117-3.527c-.887-.76-.415-2.212.749-2.305l5.404-.433 2.082-5.006z"
                clip-rule="evenodd"
              />
            </svg>
            <svg
              class="w-6 h-6 cursor-pointer rating-star hover:text-orange-400"
              data-rating="4"
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 24 24"
              fill="currentColor"
            >
              <path
                fill-rule="evenodd"
                d="M10.788 3.21c.448-1.077 1.976-1.077 2.424 0l2.082 5.007 5.404.433c1.164.093 1.636 1.545.749 2.305l-4.117 3.527 1.257 5.273c.271 1.136-.964 2.033-1.96 1.425L12 18.354 7.373 21.18c-.996.608-2.231-.29-1.96-1.425l1.257-5.273-4.117-3.527c-.887-.76-.415-2.212.749-2.305l5.404-.433 2.082-5.006z"
                clip-rule="evenodd"
              />
            </svg>
            <svg
              class="w-6 h-6 cursor-pointer rating-star hover:text-orange-400"
              data-rating="5"
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 24 24"
              fill="currentColor"
            >
              <path
                fill-rule="evenodd"
                d="M10.788 3.21c.448-1.077 1.976-1.077 2.424 0l2.082 5.007 5.404.433c1.164.093 1.636 1.545.749 2.305l-4.117 3.527 1.257 5.273c.271 1.136-.964 2.033-1.96 1.425L12 18.354 7.373 21.18c-.996.608-2.231-.29-1.96-1.425l1.257-5.273-4.117-3.527c-.887-.76-.415-2.212.749-2.305l5.404-.433 2.082-5.006z"
                clip-rule="evenodd"
              />
            </svg>
          </div>
          <input type="hidden" id="selectedRating" value="0" />
        </div>

        <div class="mb-4">
          <label
            for="reviewText"
            class="block mb-2 text-sm font-medium text-gray-700"
          >
            Your Review
          </label>
          <textarea
            id="reviewText"
            rows="3"
            class="block w-full px-3 py-2 border border-orange-300 rounded-md shadow-sm focus:ring-orange-500 focus:border-orange-500"
            placeholder="Share your experience with this provider"
          ></textarea>
        </div>

        <div class="flex justify-end space-x-4">
          <button
            type="button"
            id="closeReviewsModal"
            class="px-4 py-2 font-bold text-gray-800 transition duration-300 bg-gray-300 rounded-full hover:bg-gray-400"
          >
            Close
          </button>
          <button
            type="submit"
            id="submitReview"
            class="px-4 py-2 font-bold text-white transition duration-300 bg-orange-500 rounded-full hover:bg-orange-600"
          >
            Submit Review
          </button>
        </div>
      </form>
    </div>
  </div>

  <script>
    document.addEventListener("DOMContentLoaded", function () {
      const providerList = document.getElementById("providerList");
      const filterButtons = document.querySelectorAll('[id^="filter"]');
      const sortDistance = document.getElementById("sortDistance");
      const modal = document.getElementById("bookingModal");
      const closeModal = document.getElementById("closeModal");
      const bookingForm = document.getElementById("bookingForm");

      // Initialize cache system
      const cache = {
        providers: {},
        coordinates: {},
        maps: {},
        providerMaps: new WeakMap(), // Use WeakMap to store map instances by HTML element
        routeCache: {}, // Cache for routes
        getProviderData: function (specialty) {
          const key = specialty || "all";
          return this.providers[key];
        },
        setProviderData: function (specialty, data) {
          const key = specialty || "all";
          this.providers[key] = data;
          // Store in sessionStorage for persistence across page refreshes
          try {
            sessionStorage.setItem(`providers_${key}`, JSON.stringify(data));
          } catch (e) {
            console.warn("Could not store providers in sessionStorage:", e);
          }
        },
        getCoordinates: function (address) {
          return this.coordinates[address];
        },
        setCoordinates: function (address, coords) {
          this.coordinates[address] = coords;
          // Store in localStorage for persistence across sessions
          try {
            // Get existing coordinates from localStorage or initialize empty object
            const storedCoords = JSON.parse(
              localStorage.getItem("provider_coordinates") || "{}"
            );
            storedCoords[address] = coords;
            localStorage.setItem(
              "provider_coordinates",
              JSON.stringify(storedCoords)
            );
          } catch (e) {
            console.warn("Could not store coordinates in localStorage:", e);
          }
        },
        storeMap: function (mapElement, mapInstance) {
          this.providerMaps.set(mapElement, mapInstance);
        },
        getMap: function (mapElement) {
          return this.providerMaps.get(mapElement);
        },
        getRoute: function (start, end) {
          const key = `${start.lat},${start.lng}-${end.lat},${end.lng}`;
          return this.routeCache[key];
        },
        setRoute: function (start, end, route) {
          const key = `${start.lat},${start.lng}-${end.lat},${end.lng}`;
          this.routeCache[key] = route;

          // Try to store in sessionStorage for persistence
          try {
            // Get existing routes cache or initialize empty object
            const storedRoutes = JSON.parse(
              sessionStorage.getItem("provider_routes") || "{}"
            );
            storedRoutes[key] = route;
            sessionStorage.setItem(
              "provider_routes",
              JSON.stringify(storedRoutes)
            );
          } catch (e) {
            console.warn("Could not store route in sessionStorage:", e);
          }
        },
        loadFromStorage: function () {
          // Load cached provider data from sessionStorage
          try {
            Object.keys(sessionStorage)
              .filter((key) => key.startsWith("providers_"))
              .forEach((key) => {
                const specialty = key.replace("providers_", "");
                this.providers[specialty] = JSON.parse(
                  sessionStorage.getItem(key)
                );
              });
          } catch (e) {
            console.warn(
              "Error loading provider cache from sessionStorage:",
              e
            );
          }

          // Load cached coordinates from localStorage
          try {
            const storedCoords = JSON.parse(
              localStorage.getItem("provider_coordinates") || "{}"
            );
            this.coordinates = storedCoords;
          } catch (e) {
            console.warn(
              "Error loading coordinates cache from localStorage:",
              e
            );
          }

          // Load cached routes from sessionStorage
          try {
            const storedRoutes = JSON.parse(
              sessionStorage.getItem("provider_routes") || "{}"
            );
            this.routeCache = storedRoutes;
          } catch (e) {
            console.warn("Error loading routes cache from sessionStorage:", e);
          }
        },
      };

      // Load cached data on initialization
      cache.loadFromStorage();

      let map = null; // Initialize the map variable

      // Initialize HERE platform - but lazily only when needed
      let platform = null;
      function getPlatform() {
        if (!platform) {
          platform = new H.service.Platform({
            apikey: "lUFTE1skWuIcrj_s0wCZbbM2KWcgT2JnJcKGWHFi4WA",
          });
        }
        return platform;
      }

      let providers = [];
      let userLocation = {
        lat: 37.7749,
        lng: -122.4194,
      };

      // Try to load last known user location
      try {
        const savedLocation = JSON.parse(localStorage.getItem("user_location"));
        if (savedLocation && savedLocation.lat && savedLocation.lng) {
          userLocation = savedLocation;
        }
      } catch (e) {
        console.warn("Error loading saved location:", e);
      }

      filterButtons.forEach((button) => {
        button.addEventListener("click", () => {
          // Update button styling
          filterButtons.forEach((btn) => {
            btn.classList.remove("bg-orange-500", "text-black");
            btn.classList.add("bg-orange-100", "text-orange-800");
          });
          button.classList.remove("bg-orange-100", "text-orange-800");
          button.classList.add("bg-orange-500", "text-black");

          const specialty = button.id.replace("filter", "").replace("-", " ");
          console.log("Filtering by specialty:", specialty);
          // Check if we have cached data for this specialty
          const cachedData = cache.getProviderData(
            specialty === "All" ? null : specialty
          );
          if (cachedData) {
            providers = cachedData;
            renderProviders(providers);
            // Refresh in background to ensure data is up to date
            fetchProviders(specialty === "All" ? null : specialty, true);
          } else {
            fetchProviders(specialty === "All" ? null : specialty);
          }
        });
      });

      // Get user's location and fetch providers
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
          (position) => {
            userLocation = {
              lat: position.coords.latitude,
              lng: position.coords.longitude,
            };
            // Save user location for future visits
            try {
              localStorage.setItem(
                "user_location",
                JSON.stringify(userLocation)
              );
            } catch (e) {
              console.warn("Could not save user location:", e);
            }

            // Check if we have cached data
            const cachedData = cache.getProviderData(null);
            if (cachedData) {
              providers = cachedData;
              renderProviders(providers);
              // Refresh in background to ensure data is up to date
              fetchProviders(null, true);
            } else {
              fetchProviders();
            }
          },
          (error) => {
            console.warn("Geolocation error:", error);

            // Check if we have cached data
            const cachedData = cache.getProviderData(null);
            if (cachedData) {
              providers = cachedData;
              renderProviders(providers);
              // Refresh in background to ensure data is up to date
              fetchProviders(null, true);
            } else {
              fetchProviders();
            }
          },
          { timeout: 3000 } // 3 seconds timeout to avoid hanging
        );
      } else {
        // Check if we have cached data
        const cachedData = cache.getProviderData(null);
        if (cachedData) {
          providers = cachedData;
          renderProviders(providers);
          // Refresh in background to ensure data is up to date
          fetchProviders(null, true);
        } else {
          fetchProviders();
        }
      }

      function fetchProviders(specialty = null, isBackgroundRefresh = false) {
        // Show loading state if not a background refresh
        if (!isBackgroundRefresh) {
          providerList.innerHTML = `
                  <div class="flex items-center justify-center p-12 col-span-full">
                    <svg class="w-10 h-10 text-orange-500 animate-spin" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                      <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                      <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                  </div>
                `;
        }

        let url = `/api/providers?lat=${userLocation.lat}&lng=${userLocation.lng}`;
        if (specialty) {
          url += `&specialty=${specialty}`;
        }

        fetch(url)
          .then((response) => response.json())
          .then((data) => {
            providers = data;

            // Cache the fetched data
            cache.setProviderData(specialty, providers);

            // Preload coordinates from cache if available
            providers.forEach((provider) => {
              if (provider.address) {
                const cachedCoords = cache.getCoordinates(provider.address);
                if (cachedCoords) {
                  provider.coordinates = cachedCoords;

                  // Calculate distance if coordinates are available
                  calculateDistance(provider, true);
                }
              }
            });

            // Only render if not a background refresh
            if (!isBackgroundRefresh) {
              renderProviders(providers);
            }
          })
          .catch((error) => {
            console.error("Error:", error);
            if (!isBackgroundRefresh) {
              providerList.innerHTML = `
                      <div class="p-8 text-center border border-red-200 rounded-lg col-span-full bg-red-50">
                        <svg class="w-12 h-12 mx-auto text-red-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                        </svg>
                        <p class="mt-2 text-lg font-medium text-red-800">Unable to load providers</p>
                        <p class="mt-1 text-red-600">Please check your connection and try again</p>
                        <button onclick="window.location.reload()" class="px-4 py-2 mt-4 text-white bg-red-600 rounded-md hover:bg-red-700">
                          Retry
                        </button>
                      </div>
                    `;
            }
          });
      }

      function calculateDistance(provider, useCachedOnly = false) {
        if (!provider.address) return;

        // If we already have coordinates for this provider, calculate distance directly
        if (provider.coordinates) {
          const coords = provider.coordinates;
          provider.distance = getDistanceFromLatLonInMiles(
            userLocation.lat,
            userLocation.lng,
            coords.lat,
            coords.lng
          );

          // Update the UI to show the calculated distance
          updateDistanceDisplay(provider);
          return;
        }

        // Check if we have cached coordinates
        const cachedCoords = cache.getCoordinates(provider.address);
        if (cachedCoords) {
          provider.coordinates = cachedCoords;
          provider.distance = getDistanceFromLatLonInMiles(
            userLocation.lat,
            userLocation.lng,
            cachedCoords.lat,
            cachedCoords.lng
          );

          // Update the UI
          updateDistanceDisplay(provider);
          return;
        }

        // If we're only using cached data, exit here
        if (useCachedOnly) return;

        // Use the HERE geocoding service to get coordinates of the provider address
        const geocoder = getPlatform().getSearchService();
        geocoder.geocode(
          {
            q: provider.address,
            at: `${userLocation.lat},${userLocation.lng}`,
          },
          (result) => {
            if (result.items && result.items.length > 0) {
              const coords = result.items[0].position;

              // Cache the coordinates
              cache.setCoordinates(provider.address, {
                lat: coords.lat,
                lng: coords.lng,
              });

              // Update provider with coordinates
              provider.coordinates = {
                lat: coords.lat,
                lng: coords.lng,
              };

              // Calculate the distance
              provider.distance = getDistanceFromLatLonInMiles(
                userLocation.lat,
                userLocation.lng,
                coords.lat,
                coords.lng
              );

              // Update the UI
              updateDistanceDisplay(provider);
            }
          },
          (error) => console.error("Geocoding error:", error)
        );
      }

      function updateDistanceDisplay(provider) {
        if (!provider.distance) return;

        const distanceElements = document.querySelectorAll(
          `.distance-display[data-provider-id="${provider.id}"]`
        );
        distanceElements.forEach((el) => {
          el.textContent = `${provider.distance.toFixed(1)} miles away`;
        });
      }

      function getDistanceFromLatLonInMiles(lat1, lon1, lat2, lon2) {
        const R = 3958.8; // Radius of the Earth in miles
        const dLat = deg2rad(lat2 - lat1);
        const dLon = deg2rad(lon2 - lon1);
        const a =
          Math.sin(dLat / 2) * Math.sin(dLat / 2) +
          Math.cos(deg2rad(lat1)) *
            Math.cos(deg2rad(lat2)) *
            Math.sin(dLon / 2) *
            Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        const distance = R * c; // Distance in miles
        return distance;
      }

      function deg2rad(deg) {
        return deg * (Math.PI / 180);
      }

      function initializeProviderMap(mapDivId, address) {
        const mapDiv = document.getElementById(mapDivId);
        if (!mapDiv) return;

        // Check if we already have a map instance for this element
        let providerMap = cache.getMap(mapDiv);
        if (providerMap) {
          // Resize the map to fit container (needed after DOM changes)
          setTimeout(() => providerMap.getViewPort().resize(), 0);
          return providerMap;
        }

        // Lazy initialize platform only when needed
        const platform = getPlatform();
        const defaultLayers = platform.createDefaultLayers();

        // Check if we have cached coordinates
        const cachedCoords = cache.getCoordinates(address);

        // Create new map with optimized settings (lower pixel ratio for better performance)
        providerMap = new H.Map(mapDiv, defaultLayers.vector.normal.map, {
          zoom: 13, // Slightly less zoom for faster rendering
          pixelRatio: Math.min(window.devicePixelRatio, 1.5), // Cap at 1.5 for performance
          center: cachedCoords
            ? { lat: cachedCoords.lat, lng: cachedCoords.lng }
            : { lat: userLocation.lat, lng: userLocation.lng },
        });

        // Store map instance in cache
        cache.storeMap(mapDiv, providerMap);

        // Only add basic behavior (no UI to save resources)
        const behavior = new H.mapevents.Behavior(
          new H.mapevents.MapEvents(providerMap)
        );

        // If we have cached coordinates, use them directly
        if (cachedCoords) {
          // Simple marker with no interactions
          const marker = new H.map.Marker({
            lat: cachedCoords.lat,
            lng: cachedCoords.lng,
          });
          providerMap.addObject(marker);
        } else {
          // Batch geocoding requests to prevent rate limiting
          // Use a queue system to spread out geocoding requests
          if (!window.geocodingQueue) {
            window.geocodingQueue = [];
            window.processGeocodingQueue = function () {
              if (window.geocodingQueue.length > 0) {
                const nextItem = window.geocodingQueue.shift();
                nextItem.fn();
                // Process next item after delay
                setTimeout(window.processGeocodingQueue, 200);
              }
            };
          }

          // Add this geocoding request to queue
          window.geocodingQueue.push({
            fn: function () {
              const geocoder = platform.getSearchService();
              geocoder.geocode(
                { q: address },
                (result) => {
                  if (result.items && result.items.length > 0) {
                    const coords = result.items[0].position;

                    // Cache the coordinates
                    cache.setCoordinates(address, {
                      lat: coords.lat,
                      lng: coords.lng,
                    });

                    // Ensure the map still exists (could have been removed from DOM)
                    if (document.getElementById(mapDivId)) {
                      const marker = new H.map.Marker({
                        lat: coords.lat,
                        lng: coords.lng,
                      });
                      providerMap.addObject(marker);
                      providerMap.setCenter({
                        lat: coords.lat,
                        lng: coords.lng,
                      });
                    }
                  }
                },
                (error) => console.warn("Geocoding error:", error)
              );
            },
          });

          // Start processing queue if not already running
          if (window.geocodingQueue.length === 1) {
            window.processGeocodingQueue();
          }
        }

        return providerMap;
      }

      function renderProviders(providersToRender) {
        // Create a document fragment for better performance
        const fragment = document.createDocumentFragment();
        providerList.innerHTML = "";

        // If no providers found
        if (providersToRender.length === 0) {
          const noResults = document.createElement("div");
          noResults.className =
            "col-span-full text-center p-8 bg-orange-50 border border-orange-200 rounded-lg";
          noResults.innerHTML = `
                  <svg class="w-12 h-12 mx-auto text-orange-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 12H4" />
                  </svg>
                  <p class="mt-2 text-lg font-medium text-orange-800">No providers found</p>
                  <p class="mt-1 text-orange-600">Try adjusting your search criteria</p>
                `;
          providerList.appendChild(noResults);
          return;
        }

        // Sort providers by distance if available
        if (sortDistance.value === "asc") {
          providersToRender.sort(
            (a, b) => (a.distance || 999) - (b.distance || 999)
          );
        } else if (sortDistance.value === "desc") {
          providersToRender.sort(
            (a, b) => (b.distance || 0) - (a.distance || 0)
          );
        }

        // Create cards without maps first, then load maps in batches
        providersToRender.forEach((provider) => {
          const card = document.createElement("div");
          card.className =
            "bg-white shadow-lg rounded-lg border border-orange-200 overflow-hidden transition duration-300 transform hover:scale-105";

          const mapDivId = `map-${provider.id}`;
          const mapPlaceholderId = `map-placeholder-${provider.id}`;

          // Format distance or handle missing calculation
          const distanceDisplay = provider.distance
            ? `${provider.distance.toFixed(1)} miles away`
            : "Distance calculating...";

          const loyaltyBadge = provider.loyalty_enabled
            ? `
            <div class="p-2 mt-3 border border-orange-100 rounded-md bg-orange-50">
              <div class="flex items-center text-xs font-medium text-orange-700">
                <svg class="w-4 h-4 mr-1" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                  <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.29-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118l-2.799-2.034c-.784-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"></path>
                </svg>
                Loyalty Program
              </div>
              <div class="mt-1 text-xs">
                <p>Visit ${
                  provider.loyalty_visits_required || 10
                } times to earn: ${provider.loyalty_reward || "a reward"}</p>
                <button class="mt-1 text-xs font-medium text-orange-600 view-loyalty" onclick="window.location.href='{{ url_for('my_loyalty') }}'; return false;"  data-id="${
                  provider.id
                }">View your progress</button>
              </div>
            </div>
          `
            : "";

          // Generate inclusive care badges
          const inclusiveBadges = [];
          // Add debug logging to see what's happening
          console.log("Provider inclusive care options:", {
            lgbtq_friendly: provider.lgbtq_friendly,
            disability_accessible: provider.disability_accessible,
            cultural_responsive: provider.cultural_responsive,
            language_services: provider.language_services,
            sliding_scale: provider.sliding_scale,
            trauma_informed: provider.trauma_informed,
          });

          // Make type conversions more robust
          if (
            provider.lgbtq_friendly === true ||
            provider.lgbtq_friendly === "true" ||
            provider.lgbtq_friendly === 1
          ) {
            inclusiveBadges.push(
              '<span class="inline-block px-2 py-1 mb-1 mr-1 text-xs font-medium text-purple-700 bg-purple-100 rounded-full">LGBTQ+ Friendly</span>'
            );
          }
          if (
            provider.disability_accessible === true ||
            provider.disability_accessible === "true" ||
            provider.disability_accessible === 1
          ) {
            inclusiveBadges.push(
              '<span class="inline-block px-2 py-1 mb-1 mr-1 text-xs font-medium text-blue-700 bg-blue-100 rounded-full">Disability-Accessible</span>'
            );
          }
          if (
            provider.cultural_responsive === true ||
            provider.cultural_responsive === "true" ||
            provider.cultural_responsive === 1
          ) {
            inclusiveBadges.push(
              '<span class="inline-block px-2 py-1 mb-1 mr-1 text-xs font-medium text-green-700 bg-green-100 rounded-full">Culturally Responsive</span>'
            );
          }
          if (
            provider.language_services === true ||
            provider.language_services === "true" ||
            provider.language_services === 1
          ) {
            inclusiveBadges.push(
              '<span class="inline-block px-2 py-1 mb-1 mr-1 text-xs font-medium text-yellow-700 bg-yellow-100 rounded-full">Language Services</span>'
            );
          }
          if (
            provider.sliding_scale === true ||
            provider.sliding_scale === "true" ||
            provider.sliding_scale === 1
          ) {
            inclusiveBadges.push(
              '<span class="inline-block px-2 py-1 mb-1 mr-1 text-xs font-medium text-pink-700 bg-pink-100 rounded-full">Sliding Scale</span>'
            );
          }
          if (
            provider.trauma_informed === true ||
            provider.trauma_informed === "true" ||
            provider.trauma_informed === 1
          ) {
            inclusiveBadges.push(
              '<span class="inline-block px-2 py-1 mb-1 mr-1 text-xs font-medium text-indigo-700 bg-indigo-100 rounded-full">Trauma-Informed</span>'
            );
          }

          const inclusiveCareBadges =
            inclusiveBadges.length > 0
              ? `<div class="flex flex-wrap mb-3">
              ${inclusiveBadges.join("")}
            </div>`
              : "";

          card.innerHTML = `
            <div id="${mapPlaceholderId}" class="flex items-center justify-center w-full h-48 bg-gray-100">
              <div class="flex space-x-4 animate-pulse">
                <div class="w-10 h-10 bg-gray-200 rounded-full"></div>
                <div class="flex-1 py-1 space-y-2">
                  <div class="h-2 bg-gray-200 rounded"></div>
                  <div class="space-y-2">
                    <div class="h-2 bg-gray-200 rounded"></div>
                  </div>
                </div>
              </div>
            </div>
            <div class="p-6">
              <h3 class="mb-2 text-xl font-semibold text-gray-800">${
                provider.name
              }</h3>
              <div class="flex items-center mb-2">
                <div class="flex text-orange-400 stars-container" data-provider-id="${
                  provider.id
                }">
                  ${Array(5)
                    .fill('<span class="text-gray-300 star">★</span>')
                    .join("")}
                </div>
                <span class="ml-1 text-xs text-gray-600">
                  <span class="provider-rating" data-provider-id="${
                    provider.id
                  }">—</span>
                  (<span class="review-count" data-provider-id="${
                    provider.id
                  }">0 reviews</span>)
                </span>
              </div>
              <div class="mb-2 text-gray-600"><strong>Specialty:</strong> ${
                provider.specialty
              }</div>
              <div class="mb-2 text-gray-600"><strong>Address:</strong> ${
                provider.address
              }</div>
              <div class="mb-3 text-gray-600"><strong>Distance:</strong> <span class="distance-display" data-provider-id="${
                provider.id
              }">${distanceDisplay}</span></div>

              ${inclusiveCareBadges}

              ${loyaltyBadge}

              <div class="flex justify-between mt-4">
                <button class="px-4 py-2 font-bold text-black transition duration-300 bg-orange-500 rounded-full hover:bg-orange-600 book-appointment" data-id="${
                  provider.id
                }">Book Appointment</button>
                <button class="px-4 py-2 font-bold text-orange-800 transition duration-300 bg-orange-100 rounded-full hover:bg-orange-200 view-reviews" data-id="${
                  provider.id
                }">Reviews</button>
              </div>
            </div>
          `;

          // Store data for lazy loading
          card.dataset.providerId = provider.id;
          card.dataset.providerAddress = provider.address;
          card.dataset.mapDivId = mapDivId;
          card.dataset.mapPlaceholderId = mapPlaceholderId;

          fragment.appendChild(card);
        });

        // Add all cards to DOM
        providerList.appendChild(fragment);

        // Add event listeners for booking buttons
        document.querySelectorAll(".book-appointment").forEach((button) => {
          button.addEventListener("click", (e) => {
            const providerId = e.target.getAttribute("data-id");
            openBookingModal(providerId);
          });
        });

        // Add event listeners for review buttons
        document.querySelectorAll(".view-reviews").forEach((button) => {
          button.addEventListener("click", (e) => {
            const providerId = e.target.getAttribute("data-id");
            openReviewsModal(providerId);
          });
        });

        // Set up intersection observer to load maps only when visible
        const mapObserver = new IntersectionObserver(
          (entries) => {
            entries.forEach((entry) => {
              if (entry.isIntersecting) {
                const card = entry.target;
                const providerId = card.dataset.providerId;
                const providerAddress = card.dataset.providerAddress;
                const mapDivId = card.dataset.mapDivId;
                const mapPlaceholderId = card.dataset.mapPlaceholderId;

                // Replace placeholder with actual map
                const placeholder = document.getElementById(mapPlaceholderId);
                if (placeholder) {
                  placeholder.id = mapDivId;
                  placeholder.innerHTML = "";
                  placeholder.classList.add("provider-map-loading");

                  // Load map with a small delay to allow UI to update
                  setTimeout(() => {
                    initializeProviderMap(mapDivId, providerAddress);
                  }, 50);

                  // If distance isn't calculated yet, calculate it now
                  const provider = providersToRender.find(
                    (p) => p.id.toString() === providerId.toString()
                  );
                  if (provider && !provider.distance && provider.address) {
                    calculateDistance(provider, false);
                  }
                }

                // Stop observing this card
                mapObserver.unobserve(card);
              }
            });
          },
          {
            rootMargin: "200px", // Load maps when they're within 200px of viewport
          }
        );

        // Observe all cards for lazy loading
        document.querySelectorAll("[data-provider-id]").forEach((card) => {
          mapObserver.observe(card);
        });

        // Load ratings AFTER providers are rendered to the DOM
        loadProviderRatings();

        // Dispatch an event that providers were updated
        document.dispatchEvent(new CustomEvent("providerListUpdated"));
      }

      // Open booking modal with cached data when possible
      function openBookingModal(providerId) {
        // Try to find the provider in our local cache first
        const providerFromCache = providers.find(
          (p) => p.id.toString() === providerId.toString()
        );

        if (providerFromCache) {
          displayProviderInModal(providerFromCache);
        } else {
          // Show loading state in modal
          modal.classList.remove("hidden");
          modal.classList.add("flex");
          document.getElementById("modalTitle").textContent = "Loading...";
          document.getElementById("modalMap").innerHTML = `
                  <div class="flex items-center justify-center h-full bg-gray-100">
                    <div class="w-10 h-10 border-4 border-orange-600 rounded-full border-t-transparent animate-spin"></div>
                  </div>
                `;

          // Fetch provider data
          fetch(`/api/provider/${providerId}`)
            .then((response) => response.json())
            .then((provider) => {
              displayProviderInModal(provider);
            })
            .catch((error) => {
              console.error("Error fetching provider details:", error);
              alert("Failed to load provider details. Please try again.");

              // Close modal on error
              modal.classList.add("hidden");
              modal.classList.remove("flex");
            });
        }
      }

      function displayProviderInModal(provider) {
        console.log("Provider data received:", provider);

        // Update modal content
        document.getElementById("modalTitle").textContent = provider.name;
        document.getElementById("modalSpecialty").innerHTML =
          "<strong>Specialty:</strong> " + provider.specialty;
        document.getElementById("modalAddress").innerHTML =
          "<strong>Address:</strong> " + provider.address;
        document.getElementById("modalPhone").innerHTML =
          "<strong>Phone number:</strong> " +
          (provider.phone || "Not available");

        // Show modal if not already shown
        modal.classList.remove("hidden");
        modal.classList.add("flex");

        // Set provider ID in booking form
        bookingForm.setAttribute("data-provider-id", provider.id);

        // Initialize the appointment calendar
        initializeAppointmentCalendar(provider.id);

        // Initialize map with a delay to ensure modal is visible
        setTimeout(() => {
          // Get provider coordinates - either from provider object or from cache
          const providerCoords =
            provider.coordinates || cache.getCoordinates(provider.address);

          if (!map) {
            console.log("Initializing new map in modal");
            try {
              const defaultLayers = getPlatform().createDefaultLayers();
              map = new H.Map(
                document.getElementById("modalMap"),
                defaultLayers.vector.normal.map,
                {
                  zoom: 12,
                  pixelRatio: window.devicePixelRatio || 1,
                  center: providerCoords
                    ? { lat: providerCoords.lat, lng: providerCoords.lng }
                    : { lat: userLocation.lat, lng: userLocation.lng },
                }
              );

              // Enable map interactions
              const behavior = new H.mapevents.Behavior(
                new H.mapevents.MapEvents(map)
              );
              const ui = H.ui.UI.createDefault(map, defaultLayers);

              // Make map responsive
              window.addEventListener("resize", () => {
                if (map) map.getViewPort().resize();
              });
            } catch (error) {
              console.error("Error initializing map:", error);
            }
          } else {
            console.log("Using existing map instance");
            map.removeObjects(map.getObjects()); // Clear existing objects
          }

          // If we have coordinates, display them directly
          if (providerCoords) {
            displayRouteOnMap(providerCoords);
          } else if (provider.address) {
            // Otherwise geocode the address
            const geocoder = getPlatform().getSearchService();
            geocoder.geocode({ q: provider.address }, (result) => {
              if (result.items && result.items.length > 0) {
                const coords = result.items[0].position;

                // Cache the coordinates
                cache.setCoordinates(provider.address, {
                  lat: coords.lat,
                  lng: coords.lng,
                });

                displayRouteOnMap({
                  lat: coords.lat,
                  lng: coords.lng,
                });
              }
            });
          }
        }, 100);
      }

      // Updated function to initialize appointment calendar with row-based layout
      function initializeAppointmentCalendar(providerId) {
        const calendarContainer = document.getElementById(
          "appointmentCalendar"
        );
        const currentDateDisplay = document.getElementById("currentDate");
        const prevDateBtn = document.getElementById("prevDate");
        const nextDateBtn = document.getElementById("nextDate");
        const timeSlotsContainer = document.getElementById("timeSlots");

        // Start with current week
        let startOfWeek = new Date();
        startOfWeek.setHours(0, 0, 0, 0); // Set to beginning of day
        // Move to beginning of week (Sunday)
        startOfWeek.setDate(startOfWeek.getDate() - startOfWeek.getDay());

        // Format date range for display
        function formatDateRange(startDate) {
          const endDate = new Date(startDate);
          endDate.setDate(endDate.getDate() + 6);

          return `${startDate.toLocaleDateString("en-US", {
            month: "short",
            day: "numeric",
          })} - ${endDate.toLocaleDateString("en-US", {
            month: "short",
            day: "numeric",
            year: "numeric",
          })}`;
        }

        // Format date for API calls
        function formatDateAPI(date) {
          return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, "0")}-${String(date.getDate()).padStart(2, "0")}`;
        }

        // Update the calendar to show the week's appointments
        function updateCalendar() {
          // Update date range display
          currentDateDisplay.textContent = formatDateRange(startOfWeek);

          // Clear existing time slots
          timeSlotsContainer.innerHTML =
            '<div class="py-4 text-center">Loading appointments...</div>';

          // Create array of dates for the week
          const weekDates = [];
          for (let i = 0; i < 7; i++) {
            const date = new Date(startOfWeek);
            date.setDate(date.getDate() + i);
            weekDates.push(date);
          }

          // Set up API calls to fetch appointments for each day in the week
          const fetchPromises = weekDates.map((date) => {
            return fetch(
              `/api/provider-appointments/${providerId}?date=${formatDateAPI(
                date
              )}&status=confirmed`
            )
              .then((response) => response.json())
              .then((data) => {
                return {
                  date: date,
                  appointments: data, // No need to filter here as backend returns only confirmed
                };
              });
          });

          // Wait for all fetches to complete
          Promise.all(fetchPromises)
            .then((results) => {
              // Clear loading message
              timeSlotsContainer.innerHTML = "";

              // Create table-like structure for the calendar
              const calendarTable = document.createElement("div");
              calendarTable.className = "w-full divide-y divide-orange-200";

              // Process each day as a row
              results.forEach((dayResult, index) => {
                const dayRow = document.createElement("div");
                dayRow.className =
                  "flex w-full py-2 border-b border-orange-100";

                // Today's date gets highlighted
                const isToday =
                  dayResult.date.toDateString() === new Date().toDateString();
                if (isToday) {
                  dayRow.classList.add("bg-orange-50");
                }

                // Day header (left side)
                const dayHeader = document.createElement("div");
                dayHeader.className =
                  "w-1/4 px-2 font-medium border-r border-orange-100";
                dayHeader.innerHTML = `
                  <div class="font-bold ${
                    isToday ? "text-orange-600" : ""
                  }">${dayResult.date.toLocaleDateString("en-US", {
                  weekday: "short",
                })}</div>
                  <div class="text-sm text-gray-500">${dayResult.date.getDate()}/${
                  dayResult.date.getMonth() + 1
                }</div>
                `;

                // Appointments container (right side)
                const appointmentsContainer = document.createElement("div");
                appointmentsContainer.className =
                  "flex flex-wrap flex-1 gap-2 px-2";

                if (dayResult.appointments.length === 0) {
                  // Empty day
                  appointmentsContainer.innerHTML =
                    '<div class="w-full py-2 text-xs italic text-center text-gray-500">No appointments</div>';
                } else {
                  // Sort appointments by time
                  dayResult.appointments.sort((a, b) =>
                    a.time.localeCompare(b.time)
                  );

                  // Create appointment chips
                  dayResult.appointments.forEach((appointment) => {
                    const appointmentEl = document.createElement("div");
                    appointmentEl.className =
                      "inline-flex items-center px-2 py-1 text-xs bg-green-100 border border-green-300 rounded cursor-pointer hover:bg-green-200";

                    // Format time
                    let displayTime = "No time";
                    if (appointment.time) {
                      const [hours, minutes] = appointment.time.split(":");
                      const timeObj = new Date();
                      timeObj.setHours(parseInt(hours), parseInt(minutes));
                      displayTime = timeObj.toLocaleTimeString("en-US", {
                        hour: "numeric",
                        minute: "2-digit",
                        hour12: true,
                      });
                    }
                    appointmentEl.innerHTML = `
                      <span class="mr-1 font-medium">${displayTime} -&nbsp;</span>
                      <span class="truncate"> ${
                        appointment.type || "General"
                      }</span>
                    `;

                    // Check if this is user's confirmed appointment
                    if (
                      appointment.user_id === "{{ current_user.id }}" &&
                      appointment.status === "confirmed"
                    ) {
                      appointmentEl.classList.remove("bg-green-100");
                      appointmentEl.classList.add("bg-green-500", "text-white");
                      appointmentEl.title = "Your confirmed appointment";
                    } else {
                      appointmentEl.title = "Already booked";
                    }

                    // Click to select this appointment
                    // appointmentEl.addEventListener("click", () => {
                    //   const date = formatDateAPI(dayResult.date);
                    //   document.getElementById("appointmentDate").value = date;
                    //   document.getElementById("appointmentTime").value =
                    //     appointment.time;

                    //   // Highlight selected appointment
                    //   const allAppointments = document.querySelectorAll(
                    //     "#timeSlots .cursor-pointer"
                    //   );
                    //   allAppointments.forEach((el) => {
                    //     el.classList.remove("ring-2", "ring-orange-500");
                    //   });
                    //   appointmentEl.classList.add("ring-2", "ring-orange-500");
                    // });

                    appointmentsContainer.appendChild(appointmentEl);
                  });
                }

                // Combine day header and appointments
                dayRow.appendChild(dayHeader);
                dayRow.appendChild(appointmentsContainer);
                calendarTable.appendChild(dayRow);
              });

              timeSlotsContainer.appendChild(calendarTable);
            })
            .catch((error) => {
              console.error("Error fetching appointments:", error);
              timeSlotsContainer.innerHTML =
                '<div class="py-3 text-center text-red-500">Failed to load appointments.</div>';
            });
        }

        // Navigate to previous week
        prevDateBtn.addEventListener("click", () => {
          startOfWeek.setDate(startOfWeek.getDate() - 7);
          updateCalendar();
        });

        // Navigate to next week
        nextDateBtn.addEventListener("click", () => {
          startOfWeek.setDate(startOfWeek.getDate() + 7);
          updateCalendar();
        });

        // Initial calendar update
        updateCalendar();
      }

      function displayRouteOnMap(providerCoords) {
        // Simple version: just show markers for user and provider
        const startMarker = new H.map.Marker({
          lat: userLocation.lat,
          lng: userLocation.lng,
        });

        const endMarker = new H.map.Marker({
          lat: providerCoords.lat,
          lng: providerCoords.lng,
        });

        // Add markers to map
        map.addObjects([startMarker, endMarker]);

        // Add a route line with an artificially reduced number of points for performance
        const routingParams = {
          routingMode: "fast",
          transportMode: "car",
          origin: `${userLocation.lat},${userLocation.lng}`,
          destination: `${providerCoords.lat},${providerCoords.lng}`,
          return: "polyline",
        };

        // Try to use a cached route if possible
        const routeKey = `${userLocation.lat},${userLocation.lng}-${providerCoords.lat},${providerCoords.lng}`;

        // Set the viewport to include both points
        map.getViewModel().setLookAtData({
          bounds: new H.geo.Rect(
            Math.max(userLocation.lat, providerCoords.lat) + 0.01,
            Math.min(userLocation.lng, providerCoords.lng) - 0.01,
            Math.min(userLocation.lat, providerCoords.lat) - 0.01,
            Math.max(userLocation.lng, providerCoords.lng) + 0.01
          ),
        });

        // Calculate a simple straight line for performance
        const lineString = new H.geo.LineString();
        lineString.pushPoint({ lat: userLocation.lat, lng: userLocation.lng });
        lineString.pushPoint({
          lat: providerCoords.lat,
          lng: providerCoords.lng,
        });

        const routeLine = new H.map.Polyline(lineString, {
          style: { strokeColor: "blue", lineWidth: 3 },
        });

        map.addObject(routeLine);
      }

      // Close modal
      closeModal.addEventListener("click", () => {
        modal.classList.add("hidden");
        modal.classList.remove("flex");
      });

      // Handle booking form submission
      bookingForm.addEventListener("submit", (e) => {
        e.preventDefault();

        // Show loading state on button
        const submitBtn = e.submitter;
        const originalText = submitBtn.innerHTML;
        submitBtn.innerHTML = `
                <span class="inline-block w-4 h-4 mr-2 border-2 border-white rounded-full border-t-transparent animate-spin"></span>
                Booking...
              `;
        submitBtn.disabled = true;

        const date = document.getElementById("appointmentDate").value;
        const time = document.getElementById("appointmentTime").value;
        const appointmentType =
          document.getElementById("appointmentType").value;
        const providerId = bookingForm.getAttribute("data-provider-id");

        // Get CSRF token
        const csrfToken = document
          .querySelector('meta[name="csrf-token"]')
          .getAttribute("content");

        // Send data to backend
        fetch("/api/book-appointment", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-CSRF-Token": csrfToken,
          },
          body: JSON.stringify({
            provider_id: providerId,
            date: date,
            time: time,
            appointment_type: appointmentType,
          }),
        })
          .then((response) => {
            if (!response.ok) {
              throw new Error("Booking failed");
            }
            return response.json();
          })
          .then((data) => {
            // Show success notification
            const notification = document.createElement("div");
            notification.className =
              "fixed top-4 right-4 bg-green-500 text-white px-6 py-3 rounded-lg shadow-lg transform transition-all duration-500";
            notification.innerHTML = `
                  <div class="flex items-center">
                    <svg class="w-6 h-6 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                    </svg>
                    <div>
                      <p class="font-bold">Appointment Booked!</p>
                      <p class="text-sm">${appointmentType} on ${date} at ${time}</p>
                    </div>
                  </div>
                `;

            document.body.appendChild(notification);

            // Remove notification after 5 seconds
            setTimeout(() => {
              notification.style.opacity = "0";
              setTimeout(() => notification.remove(), 500);
            }, 5000);

            // Close modal
            modal.classList.add("hidden");
            modal.classList.remove("flex");

            // Reset form
            bookingForm.reset();
          })
          .catch((error) => {
            console.error("Booking error:", error);
            // Show error notification
            const errorNotification = document.createElement("div");
            errorNotification.className =
              "fixed top-4 right-4 bg-red-500 text-white px-6 py-3 rounded-lg shadow-lg";
            errorNotification.innerHTML = `
                  <div class="flex items-center">
                    <svg class="w-6 h-6 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                    <div>
                      <p class="font-bold">Booking Failed</p>
                      <p class="text-sm">Please try again later</p>
                    </div>
                  </div>
                `;

            document.body.appendChild(errorNotification);
            setTimeout(() => {
              errorNotification.style.opacity = "0";
              setTimeout(() => errorNotification.remove(), 500);
            }, 5000);

            // Reset button state
            submitBtn.innerHTML = originalText;
            submitBtn.disabled = false;
          });
      });

      // Rating system initialization
      const reviewsCache = {};
      const reviewsModal = document.getElementById("reviewsModal");
      const closeReviewsModal = document.getElementById("closeReviewsModal");
      const reviewForm = document.getElementById("reviewForm");
      const reviewSort = document.getElementById("reviewSort");
      let currentProviderId = null;

      // Load provider ratings on initial load
      function loadProviderRatings() {
        console.log("Loading provider ratings...");
        const providerElements =
          document.querySelectorAll("[data-provider-id]");
        console.log(
          `Found ${providerElements.length} provider elements to load ratings for`
        );

        providerElements.forEach((element) => {
          const providerId = element.dataset.providerId;
          if (providerId) {
            console.log("Found provider ID:", providerId);
            // Debounce and batch requests to avoid overwhelming the server
            setTimeout(() => {
              fetchProviderRating(providerId);
            }, Math.random() * 1000); // Random delay between 0-1000ms
          }
        });
      }

      // Fetch provider rating and update UI
      function fetchProviderRating(providerId) {
        console.log("Fetching rating for provider:", providerId);

        // Check cache first
        if (reviewsCache[providerId] && reviewsCache[providerId].summary) {
          console.log("Using cached rating data");
          updateRatingDisplay(providerId, reviewsCache[providerId].summary);
          return;
        }

        // Otherwise fetch from server
        console.log("Requesting rating from server for:", providerId);
        fetch(`/api/provider-ratings/${providerId}`)
          .then((response) => {
            console.log("Rating API response:", response.status);
            return response.json();
          })
          .then((data) => {
            console.log("Rating data received:", data);
            reviewsCache[providerId] = {
              summary: data,
              reviews: null, // We'll fetch reviews only when needed
            };
            updateRatingDisplay(providerId, data);
          })
          .catch((error) => {
            console.error("Error fetching ratings:", error);
          });
      }

      // Update UI with rating information
      function updateRatingDisplay(providerId, data) {
        console.log(
          `Updating display for provider ${providerId} with rating ${data.average_rating}`
        );

        // Update rating text
        const ratingElements = document.querySelectorAll(
          `.provider-rating[data-provider-id="${providerId}"]`
        );
        ratingElements.forEach((el) => {
          el.textContent = data.average_rating
            ? data.average_rating.toFixed(1)
            : "—";
        });

        // Update review count text
        const reviewCountElements = document.querySelectorAll(
          `.review-count[data-provider-id="${providerId}"]`
        );
        reviewCountElements.forEach((el) => {
          el.textContent = `${data.review_count || 0} ${
            data.review_count === 1 ? "review" : "reviews"
          }`;
        });

        // Update star display
        const starsContainers = document.querySelectorAll(
          `.stars-container[data-provider-id="${providerId}"]`
        );

        starsContainers.forEach((container) => {
          const rating = data.average_rating || 0;
          container.dataset.rating = rating;

          const stars = container.querySelectorAll(".star");
          stars.forEach((star, index) => {
            // Use data-star-index to determine position (1-based)
            const position = parseInt(star.dataset.starIndex || index + 1);

            // For whole stars
            if (position <= Math.floor(rating)) {
              star.setAttribute("fill", "currentColor");
              star.setAttribute("stroke", "none");
            }
            // For partial star
            else if (position === Math.floor(rating) + 1 && rating % 1 > 0) {
              const percentage = (rating % 1) * 100;
              star.innerHTML = `
                <defs>
                  <linearGradient id="partialFill-${providerId}-${position}" x1="0" x2="1" y1="0" y2="0">
                    <stop offset="${rating % 1}" stop-color="currentColor" />
                    <stop offset="${
                      rating % 1
                    }" stop-color="transparent" stop-opacity="0" />
                  </linearGradient>
                </defs>
                <path fill="url(#partialFill-${providerId}-${position})"
                      stroke="currentColor"
                      stroke-width="1.5"
                      d="M11.049 2.927c.3-.921 1.603-.921 1.902 0l1.519 4.674a1 1 0 00.95.69h4.915c.969 0 1.371 1.24.588 1.81l-3.976 2.888a1 0 00-.363 1.118l1.518 4.674c.3.922-.755 1.688-1.538 1.118l-3.976-2.888a1 1 0 00-1.176 0l-3.976 2.888c-.783.57-1.838-.197-1.538-1.118l1.518-4.674a1 0 00-.363-1.118l-3.976-2.888c-.784-.57-.38-1.81.588-1.81h4.914a1 1 0 00.951-.69l1.519-4.674z" />
              `;
            }
            // Empty stars
            else {
              star.setAttribute("fill", "none");
              star.setAttribute("stroke", "currentColor");
            }
          });
        });
      }

      // Fill stars based on rating
      function updateStars(container, rating) {
        const stars = container.querySelectorAll(".star");
        stars.forEach((star, index) => {
          // For whole stars
          if (index < Math.floor(rating)) {
            star.setAttribute("fill", "currentColor");
            star.style.color = "#f97316"; // orange-500
          }
          // For partial star
          else if (index === Math.floor(rating) && rating % 1 > 0) {
            star.innerHTML = createPartialStar(rating % 1);
            star.style.color = "#f97316"; // orange-500
          }
          // Empty stars
          else {
            star.setAttribute("fill", "none");
            star.style.color = "#d1d5db"; // gray-300
          }
        });
      }

      // Create SVG for partial star
      function createPartialStar(percentage) {
        return `<defs>
          <linearGradient id="partialFill" x1="0" x2="1" y1="0" y2="0">
            <stop offset="${percentage}" stop-color="currentColor" />
            <stop offset="${percentage}" stop-color="transparent" stop-opacity="0" />
          </linearGradient>
        </defs>
        <path fill="url(#partialFill)" stroke="currentColor" stroke-width="2" d="M11.049 2.927c.3-.921 1.603-.921 1.902 0l1.519 4.674a1 1 0 00.95.69h4.915c.969 0 1.371 1.24.588 1.81l-3.976 2.888a1 0 00-.363 1.118l1.518 4.674c.3.922-.755 1.688-1.538 1.118l-3.976-2.888a1 1 0 00-1.176 0l-3.976 2.888c-.783.57-1.838-.197-1.538-1.118l1.518-4.674a1 1 0 00-.363-1.118l-3.976-2.888c-.784-.57-.38-1.81.588-1.81h4.914a1 1 0 00.951-.69l1.519-4.674z" />`;
      }

      // View reviews button click handler
      function addReviewEventListeners() {
        document.querySelectorAll(".view-reviews").forEach((button) => {
          button.addEventListener("click", (e) => {
            const providerId = e.target.getAttribute("data-id");
            openReviewsModal(providerId);
          });
        });
      }

      // Open reviews modal
      function openReviewsModal(providerId) {
        currentProviderId = providerId;

        // Get provider name
        let providerName = "Provider";
        const cardElement = document
          .querySelector(`[data-provider-id="${providerId}"]`)
          .closest(".bg-white");
        if (cardElement) {
          const nameElement = cardElement.querySelector("h3");
          if (nameElement) {
            providerName = nameElement.textContent.trim();
          }
        }

        document.getElementById(
          "reviewsModalTitle"
        ).textContent = `Reviews for ${providerName}`;

        // Reset form
        document.getElementById("selectedRating").value = "0";
        document.getElementById("reviewText").value = "";
        const ratingStars = document.querySelectorAll(
          "#ratingSelector .rating-star"
        );
        ratingStars.forEach((star) => star.classList.remove("text-orange-500"));

        // Display the modal
        reviewsModal.classList.remove("hidden");
        reviewsModal.classList.add("flex");

        // Load reviews
        loadReviews(providerId);
      }

      // Load reviews for a provider
      function loadReviews(providerId, sortBy = "recent") {
        const reviewsList = document.getElementById("reviewsList");
        reviewsList.innerHTML = `
          <div class="flex items-center justify-center p-8">
            <div class="w-8 h-8 border-4 border-orange-600 rounded-full border-t-transparent animate-spin"></div>
          </div>
        `;

        // Fetch reviews from server or cache
        if (reviewsCache[providerId] && reviewsCache[providerId].reviews) {
          displayReviews(providerId, reviewsCache[providerId].reviews, sortBy);
        } else {
          fetch(`/api/provider-reviews/${providerId}`)
            .then((response) => response.json())
            .then((data) => {
              if (!reviewsCache[providerId]) {
                reviewsCache[providerId] = {};
              }
              reviewsCache[providerId].reviews = data;
              displayReviews(providerId, data, sortBy);
            })
            .catch((error) => {
              console.error("Error fetching reviews:", error);
              reviewsList.innerHTML = `
                <div class="p-6 text-center text-red-500">
                  Failed to load reviews. Please try again.
                </div>
              `;
            });
        }

        // Display rating summary in modal header
        if (reviewsCache[providerId] && reviewsCache[providerId].summary) {
          const summary = reviewsCache[providerId].summary;
          document.getElementById("modalRating").textContent =
            summary.average_rating ? summary.average_rating.toFixed(1) : "—";
          document.getElementById("modalReviewCount").textContent = `${
            summary.review_count || 0
          } ${summary.review_count === 1 ? "review" : "reviews"}`;

          // Update stars in modal
          updateModalStars(summary.average_rating || 0);
        }
      }

      // Update stars in the reviews modal
      function updateModalStars(rating) {
        const modalStarsContainer = document.getElementById(
          "modalStarsContainer"
        );
        modalStarsContainer.innerHTML = "";

        for (let i = 0; i < 5; i++) {
          const star = document.createElement("svg");
          star.classList.add("w-5", "h-5", "star");
          star.setAttribute("xmlns", "http://www.w3.org/2000/svg");
          star.setAttribute("viewBox", "0 0 24 24");

          if (i < Math.floor(rating)) {
            // Full star
            star.setAttribute("fill", "currentColor");
            star.innerHTML =
              '<path fill-rule="evenodd" d="M10.788 3.21c.448-1.077 1.976-1.077 2.424 0l2.082 5.007 5.404.433c1.164.093 1.636 1.545.749 2.305l-4.117 3.527 1.257 5.273c.271 1.136-.964 2.033-1.96 1.425L12 18.354 7.373 21.18c-.996.608-2.231-.29-1.96-1.425l1.257-5.273-4.117-3.527c-.887-.76-.415-2.212.749-2.305l5.404-.433 2.082-5.006z" clip-rule="evenodd" />';
          } else if (i === Math.floor(rating) && rating % 1 > 0) {
            // Partial star
            star.innerHTML = createPartialStar(rating % 1);
          } else {
            // Empty star
            star.setAttribute("fill", "none");
            star.setAttribute("stroke", "currentColor");
            star.innerHTML =
              '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11.049 2.927c.3-.921 1.603-.921 1.902 0l1.519 4.674a1 1 0 00.95.69h4.915c.969 0 1.371 1.24.588 1.81l-3.976 2.888a1 0 00-.363 1.118l1.518 4.674c.3.922-.755 1.688-1.538 1.118l-3.976-2.888a1 1 0 00-1.176 0l-3.976 2.888c-.783.57-1.838-.197-1.538-1.118l1.518-4.674a1 0 00-.363-1.118l-3.976-2.888c-.784-.57-.38-1.81.588-1.81h4.914a1 1 0 00.951-.69l1.519-4.674z" />';
          }

          modalStarsContainer.appendChild(star);
        }
      }

      // Display reviews in the modal
      function displayReviews(providerId, reviews, sortBy) {
        const reviewsList = document.getElementById("reviewsList");

        // Sort reviews
        let sortedReviews = [...reviews];
        switch (sortBy) {
          case "recent":
            sortedReviews.sort(
              (a, b) => new Date(b.created_at) - new Date(a.created_at)
            );
            break;
          case "highest":
            sortedReviews.sort((a, b) => b.rating - a.rating);
            break;
          case "lowest":
            sortedReviews.sort((a, b) => a.rating - b.rating);
            break;
        }

        // If no reviews
        if (sortedReviews.length === 0) {
          reviewsList.innerHTML = `
                  <div class="p-6 text-center text-gray-500">
                    No reviews yet. Be the first to review this provider!
                  </div>
                `;
          return;
        }

        // Display reviews
        reviewsList.innerHTML = "";
        sortedReviews.forEach((review) => {
          // Convert Firestore timestamp to JS Date if needed
          let reviewDate;
          if (review.created_at && review.created_at.seconds) {
            // Handle Firestore timestamp format
            reviewDate = new Date(review.created_at.seconds * 1000);
          } else if (review.created_at) {
            // Handle string or Date object
            reviewDate = new Date(review.created_at);
          } else {
            reviewDate = new Date(); // Fallback
          }

          const formattedDate = reviewDate.toLocaleDateString("en-US", {
            year: "numeric",
            month: "short",
            day: "numeric",
          });

          const reviewElement = document.createElement("div");
          reviewElement.className =
            "p-4 mb-4 border-b border-gray-100 last:border-0";
          reviewElement.innerHTML = `
                  <div class="flex items-center mb-2">
                    <div class="flex text-orange-400">
                      ${Array.from({ length: 5 }, (_, i) =>
                        i < review.rating
                          ? '<svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path fill-rule="evenodd" d="M10.788 3.21c.448-1.077 1.976-1.077 2.424 0l2.082 5.007 5.404.433c1.164.093 1.636 1.545.749 2.305l-4.117 3.527 1.257 5.273c.271 1.136-.964 2.033-1.96 1.425L12 18.354 7.373 21.18c-.996.608-2.231-.29-1.96-1.425l1.257-5.273-4.117-3.527c-.887-.76-.415-2.212.749-2.305l5.404-.433 2.082-5.006z" clip-rule="evenodd" /></svg>'
                          : '<svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11.049 2.927c.3-.921 1.603-.921 1.902 0l1.519 4.674a1 1 0 00.95.69h4.915c.969 0 1.371 1.24.588 1.81l-3.976 2.888a1 0 00-.363 1.118l1.518 4.674c.3.922-.755 1.688-1.538 1.118l-3.976-2.888a1 1 0 00-1.176 0l-3.976 2.888c-.783.57-1.838-.197-1.538-1.118l1.518-4.674a1 0 00-.363-1.118l-3.976-2.888c-.784-.57-.38-1.81.588-1.81h4.914a1 1 0 00.951-.69l1.519-4.674z" /></svg>'
                      ).join("")}
                    </div>
                    <span class="ml-2 text-sm font-medium text-gray-600">${
                      review.user_name || "Anonymous User"
                    }</span>
                    <span class="ml-auto text-sm text-gray-400">${formattedDate}</span>
                  </div>
                  <p class="text-gray-700">${review.text}</p>
                `;

          reviewsList.appendChild(reviewElement);
        });
      }

      // Handle review sorting
      reviewSort.addEventListener("change", (e) => {
        if (currentProviderId) {
          loadReviews(currentProviderId, e.target.value);
        }
      });

      // Close reviews modal
      closeReviewsModal.addEventListener("click", () => {
        reviewsModal.classList.add("hidden");
        reviewsModal.classList.remove("flex");
      });

      // Rating star selection
      const ratingStars = document.querySelectorAll(
        "#ratingSelector .rating-star"
      );
      ratingStars.forEach((star) => {
        star.addEventListener("click", () => {
          const rating = parseInt(star.getAttribute("data-rating"));
          document.getElementById("selectedRating").value = rating;

          // Update star appearance
          ratingStars.forEach((s) => {
            if (parseInt(s.getAttribute("data-rating")) <= rating) {
              s.classList.add("text-orange-500");
              s.classList.remove("text-gray-300");
            } else {
              s.classList.remove("text-orange-500");
              s.classList.add("text-gray-300");
            }
          });
        });

        // Hover effects
        star.addEventListener("mouseenter", () => {
          const rating = parseInt(star.getAttribute("data-rating"));
          ratingStars.forEach((s) => {
            if (parseInt(s.getAttribute("data-rating")) <= rating) {
              s.classList.add("text-orange-400");
              s.classList.remove("text-gray-300");
            }
          });
        });

        star.addEventListener("mouseleave", () => {
          const selectedRating = parseInt(
            document.getElementById("selectedRating").value
          );
          ratingStars.forEach((s) => {
            const starRating = parseInt(s.getAttribute("data-rating"));
            if (starRating <= selectedRating) {
              s.classList.add("text-orange-500");
              s.classList.remove("text-gray-300", "text-orange-400");
            } else {
              s.classList.remove("text-orange-500", "text-orange-400");
              s.classList.add("text-gray-300");
            }
          });
        });
      });

      // Handle review form submission
      reviewForm.addEventListener("submit", (e) => {
        e.preventDefault();

        if (!currentProviderId) {
          console.error("No provider selected for review");
          return;
        }

        const rating = parseInt(
          document.getElementById("selectedRating").value
        );
        const reviewText = document.getElementById("reviewText").value.trim();

        if (rating === 0) {
          // Show error for no rating
          const ratingError = document.createElement("div");
          ratingError.className = "text-sm text-red-500 mt-1 mb-4";
          ratingError.textContent = "Please select a rating";

          // Remove any existing error messages
          const existingError = document.querySelector(".rating-error");
          if (existingError) existingError.remove();

          // Add error message
          ratingError.classList.add("rating-error");
          document
            .getElementById("ratingSelector")
            .parentNode.appendChild(ratingError);

          // Clear error after 3 seconds
          setTimeout(() => ratingError.remove(), 3000);

          return;
        }

        // Disable submit button and show loading state
        const submitButton = document.getElementById("submitReview");
        const originalText = submitButton.innerHTML;
        submitButton.disabled = true;
        submitButton.innerHTML = `
                <span class="inline-block w-4 h-4 mr-2 border-2 border-white rounded-full border-t-transparent animate-spin"></span>
                Submitting...
              `;

        // Get CSRF token
        const csrfToken = document
          .querySelector('meta[name="csrf-token"]')
          ?.getAttribute("content");

        // Send review to backend
        fetch("/api/submit-review", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-CSRF-Token": csrfToken || "",
          },
          body: JSON.stringify({
            provider_id: currentProviderId,
            rating: rating,
            review_text: reviewText,
          }),
        })
          .then((response) => {
            if (!response.ok) {
              throw new Error("Review submission failed");
            }
            return response.json();
          })
          .then((data) => {
            // Reset form
            document.getElementById("selectedRating").value = "0";
            document.getElementById("reviewText").value = "";
            ratingStars.forEach((star) => {
              star.classList.remove("text-orange-500");
              star.classList.add("text-gray-300");
            });

            // Show success message
            const successNotification = document.createElement("div");
            successNotification.className =
              "fixed top-4 right-4 bg-green-500 text-white px-6 py-3 rounded-lg shadow-lg transform transition-all duration-500";
            successNotification.innerHTML = `
                  <div class="flex items-center">
                    <svg class="w-6 h-6 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                    </svg>
                    <div>
                      <p class="font-bold">Thank You!</p>
                      <p class="text-sm">Your review has been submitted</p>
                    </div>
                  </div>
                `;

            document.body.appendChild(successNotification);

            // Remove notification after 5 seconds
            setTimeout(() => {
              successNotification.style.opacity = "0";
              setTimeout(() => successNotification.remove(), 500);
            }, 5000);

            // Refresh the reviews
            if (reviewsCache[currentProviderId]) {
              // Invalidate the cache to fetch fresh data
              delete reviewsCache[currentProviderId];
            }

            // Reload reviews
            loadReviews(currentProviderId, reviewSort.value);

            // Also reload the provider ratings summary
            fetchProviderRating(currentProviderId);

            // Update all instances of this provider's rating on the page
            loadProviderRatings();
          })
          .catch((error) => {
            console.error("Review submission error:", error);

            // Show error notification
            const errorNotification = document.createElement("div");
            errorNotification.className =
              "fixed top-4 right-4 bg-red-500 text-white px-6 py-3 rounded-lg shadow-lg";
            errorNotification.innerHTML = `
                  <div class="flex items-center">
                    <svg class="w-6 h-6 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                    <div>
                      <p class="font-bold">Review Failed</p>
                      <p class="text-sm">Please try again later</p>
                    </div>
                  </div>
                `;

            document.body.appendChild(errorNotification);

            setTimeout(() => {
              errorNotification.style.opacity = "0";
              setTimeout(() => errorNotification.remove(), 500);
            }, 5000);
          })
          .finally(() => {
            // Reset button state
            submitButton.innerHTML = originalText;
            submitButton.disabled = false;
          });
      });

      // Add event listeners for review buttons
      addReviewEventListeners();

      // Load provider ratings on initial load
      loadProviderRatings();
    });
  </script>
</div>
{% endblock %}
